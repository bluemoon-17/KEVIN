# 📚 고급 자료구조 및 알고리즘 심화 정리 (Final Exam Prep)

## 1. 🔗 연결된 구조 (Linked Structure)의 심층 분석

### 1.1 메모리 관리 및 효율성 비교

| 구분 | **배열 구조 (Array Structure)** | **연결된 구조 (Linked Structure)** |
| :--- | :--- | :--- |
| **메모리 할당 방식** | 정적 (Static) 또는 초기 크기 고정 **연속적인 메모리** 확보 | 동적 (Dynamic), 시스템 메모리가 허용하는 한 **비연속적인 메모리** 활용 |
| **데이터 접근** | 랜덤 접근 (Random Access) 가능, $O(1)$ | **순차 접근 (Sequential Access)**만 가능, $O(n)$ |
| **삽입/삭제 위치** | 중간 삽입/삭제 시 **$O(n)$**의 자료 이동 발생 | 중간 삽입/삭제 시 $O(1)$ (단, 이전 노드(before)를 알고 있을 때) |
| **단점** | 메모리 낭비 (용량이 고정됨), 오버플로 발생 가능 | 추가 메모리 (**링크 필드**) 필요, $n$번째 노드 탐색 시 시간이 오래 걸림 |

* **노드의 구성**: 노드는 최소한 **데이터 필드**와 다음 노드의 주소를 가리키는 **링크 필드**로 이루어집니다.

### 1.2 연결된 구조의 응용: 큐의 효율화

#### 원형 연결 구조의 큐 (Circular Linked Queue)

* **특징**: 마지막 노드(`rear` 또는 `tail`)가 첫 노드(`front`)를 가리키도록 연결하여 전체 리스트를 순환시킵니다.
* **구현상의 이점**: 큐의 시작과 끝을 동시에 관리할 필요 없이, **`tail` 포인터 하나만** 저장합니다.
    * `rear` 노드: `tail`이 가리키는 노드.
    * `front` 노드: `tail`이 가리키는 노드의 링크 필드(`tail.link`)가 가리키는 노드.
* **시간 복잡도**: 삽입(`enqueue`)과 삭제(`dequeue`) 연산 모두 **$O(1)$**로 수행 가능합니다.

---

## 2. 🔍 정렬 및 탐색 알고리즘 (Sorting & Searching)

### 2.1 $O(n^2)$ 정렬 알고리즘

이들은 효율성은 낮지만 구현이 간단하며, 데이터가 적을 때나 거의 정렬되어 있을 때 유용합니다.

* **선택 정렬 (Selection Sort)**
    * **원리**: 매 단계에서 가장 작은 (또는 큰) 원소를 나머지 리스트에서 찾아 현재 위치와 **교환**하여 정렬된 부분을 늘려갑니다.
    * **특징**: 데이터 비교 횟수는 $O(n^2)$이지만, **교환 (Swap) 횟수는 $O(n)$으로 가장 적습니다.**
* **삽입 정렬 (Insertion Sort)**
    * **원리**: 현재 원소를 이미 정렬된 앞부분에 올바른 위치를 찾아 **끼워 넣는(삽입)** 방식으로 정렬합니다.
    * **특징**: 데이터가 거의 정렬되어 있는 **최상의 경우 $O(n)$의 성능**을 보입니다.

### 2.2 심화 탐색 기법: 해싱 (Hashing)

* **목표**: 탐색 키 $k$를 해시 함수 $h(k)$를 통해 메모리 주소로 직접 변환하여 평균 **$O(1)$**의 속도로 탐색합니다.
* **오버플로 해결 (Collision Resolution)**: 해싱의 성능을 좌우하는 핵심은 충돌을 어떻게 해결하느냐입니다.
    1.  **개방 주소법 (Open Addressing)**: 충돌이 발생하면 해시 테이블의 다른 비어있는 위치를 찾아 저장합니다.
        * **선형 조사법 (Linear Probing)**: 충돌이 발생하면 $h(k)+1, h(k)+2, \dots$ 순서로 순차적으로 다음 위치를 조사합니다.
            * **치명적인 문제**: **1차 군집화 (Primary Clustering)** 현상이 발생합니다. 데이터가 해시 테이블의 특정 영역에 집중되어 탐색 시간이 $O(n)$에 가까워질 수 있습니다.
        * **이차 조사법 (Quadratic Probing)**: $h(k)+1^2, h(k)+2^2, \dots$ 순서로 조사하여 1차 군집화를 완화합니다.

![Circular Linked Queue Structure](https://github.com/bluemoon-17/KEVIN/blob/main/2Grade/2Simester/Data%20Structure/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202025-12-07%20214233.png)

    2.  **체이닝 (Chaining)**: 하나의 해시 주소(버킷)에 충돌된 모든 항목을 저장하기 위한 **연결 리스트**를 연결합니다.
        * **장점**: 구현이 비교적 쉽고, 테이블 크기 $M$보다 많은 항목을 저장할 수 있습니다.
        * **단점**: 추가 메모리 (링크 필드)가 필요하며, 연결 리스트가 길어지면 탐색 시간이 증가합니다.

---

## 3. 🌳 트리 (Tree) 자료구조와 특수 트리

### 3.1 트리의 용어 및 속성 상세

| 용어 | 상세 정의 |
| :--- | :--- |
| **단말 노드 (Leaf Node)** | 차수가 0인 노드 (자식이 없는 노드)이며, 트리의 가장 낮은 레벨에 위치합니다. |
| **비단말 노드 (Non-terminal Node)** | 자식 노드를 가진 노드. |
| **포레스트 (Forest)** | 트리의 집합을 의미하며, 간선을 제거하여 여러 개의 서브트리가 생성될 때 나타납니다. |
| **트리의 높이** | 루트에서 가장 깊은 레벨의 단말 노드까지의 경로 길이. 트리의 탐색 깊이를 결정합니다. |
| **간선의 개수** | 노드 개수가 $n$개인 트리에서 간선의 개수는 항상 **$n-1$**개입니다. |

### 3.2 이진 트리의 분류

* **포화 이진 트리 (Full Binary Tree)**: 트리의 모든 레벨에 노드가 꽉 채워진 이진 트리. 높이 $h$일 때, 노드의 개수는 $2^h - 1$개입니다.
* **완전 이진 트리 (Complete Binary Tree)**: 트리의 마지막 레벨을 제외한 모든 레벨이 포화되어 있고, 마지막 레벨에서는 노드가 **왼쪽부터 채워진** 이진 트리. (**힙 트리 구현의 전제 조건**)
* **편향 이진 트리 (Skewed Tree)**: 모든 노드가 하나의 자식만 가져 한쪽으로만 기울어진 트리. 이 경우 BST의 탐색 효율성은 $O(n)$으로 저하됩니다.

### 3.3 이진 트리의 순회 (Traversal)

| 순회 방법 | 방문 순서 (재귀) | 핵심 특징 및 용도 |
| :--- | :--- | :--- |
| **전위 순회 (Preorder)** | **루트** $\rightarrow$ 왼쪽 $\rightarrow$ 오른쪽 | 수식의 **전위 표기 (Prefix)** 계산, 트리의 구조 파악, 트리의 복사 |
| **중위 순회 (Inorder)** | 왼쪽 $\rightarrow$ **루트** $\rightarrow$ 오른쪽 | 이진 탐색 트리의 노드를 **정렬된 순서로 출력** (가장 중요) |
| **후위 순회 (Postorder)** | 왼쪽 $\rightarrow$ 오른쪽 $\rightarrow$ **루트** | 수식의 **후위 표기 (Postfix)** 계산, 노드와 서브트리를 삭제할 때 사용 |
| **레벨 순회 (Level-order)** | 레벨 순서대로 방문 | **큐 (Queue)**를 사용하여 구현합니다. |

### 3.4 힙 트리 (Heap Tree)의 연산

#### 힙 속성 (Heap Property)
* **최대 힙**: $\text{Parent} \ge \text{Child}$
* **최소 힙**: $\text{Parent} \le \text{Child}$

#### 삽입 연산 (Up-heap)
1.  새 요소를 **말단 위치 (가장 마지막 위치)**에 삽입합니다.
2.  새 요소가 **부모 노드와 힙 조건을 만족할 때까지 위로 승진 (Swap)** 시킵니다.
3.  **시간 복잡도**: 트리의 높이에 비례하는 $O(\log n)$.

#### 삭제 연산 (Down-heap)
1.  항상 **루트 노드**를 삭제합니다 (최대/최소 값).
2.  힙의 **말단 노드**를 삭제된 루트 위치로 이동시킵니다.
3.  새 루트 노드가 **자식 노드와 힙 조건을 만족할 때까지 아래로 강등 (Swap)** 시킵니다.
4.  **시간 복잡도**: $O(\log n)$.

---

## 4. 🔑 이진 탐색 트리 (Binary Search Tree - BST)

### 4.1 BST의 효율성 및 탐색

* **정의**: 키 순서가 있는 이진 트리. ($\text{왼쪽 서브트리} < \text{루트 노드} < \text{오른쪽 서브트리}$)
* **균형 트리의 효율성**: 트리가 **균형을 유지**할 경우, 탐색/삽입/삭제 모두 **$O(\log n)$**의 성능을 가집니다.

### 4.2 삭제 연산 (Deletion Operation) 상세

삭제 연산은 BST의 속성을 유지하기 위해 가장 복잡합니다.

#### 케이스 정리

| Case | 삭제할 노드 $(N)$의 상태 | 처리 방법 |
| :--- | :--- | :--- |
| **Case 1** | 단말 노드 (자식 0개) | 노드 $N$의 부모 노드가 $N$을 가리키던 링크를 **`None`**으로 설정하고 $N$을 메모리에서 해제합니다. |
| **Case 2** | 자식이 1개 | $N$의 부모가 $N$을 건너뛰어 $N$의 **유일한 자식**을 가리키도록 링크를 직접 수정합니다. |
| **Case 3** | 자식이 2개 | $N$을 대체할 **후계자 (Successor)** 노드를 찾아 키 값을 복사한 후, 후계자 노드를 삭제합니다. |

#### ✔ 후계자 선택
* **$N$의 오른쪽 서브트리에서 가장 작은 키를 가진 노드**

#### ✔ 후계자의 특징
* 후계자는 반드시 **자식이 0개이거나 1개** (왼쪽 자식이 없음)이므로, 삭제 시 **Case 1 또는 Case 2**를 적용하여 간단하게 처리할 수 있습니다.
