## 📚 '파이썬으로 쉽게 배우는 자료구조 [개정판]' 1장 ~ 5장 상세 요약

---

## 1장: 자료구조와 알고리즘 (개념 및 성능 분석)

### 1. 핵심 개념 정의

| 개념 | 정의 | ADT (추상 자료형, Abstract Data Type) |
| :--- | :--- | :--- |
| **자료구조** | 데이터를 효율적으로 저장하고 관리하는 방식. | 구현 방식과 독립적으로, 자료구조가 제공하는 **연산의 명세**만 정의한 것. |
| **알고리즘** | 주어진 문제를 해결하기 위한 **단계적인 절차**나 방법. | |

### 2. 알고리즘 성능 분석 (시간 복잡도 계산)

알고리즘의 실행 시간을 입력 크기 $n$의 함수로 나타내는 **시간 복잡도**를 **빅오 표기법**으로 측정합니다.

| 빅오 표기법 | 명칭 | $n$에 따른 실행 시간 증가율 | 주요 계산 예시 |
| :---: | :--- | :--- | :--- |
| $O(1)$ | **상수 시간** | 입력 크기와 무관하게 일정함. | 배열/리스트에서 인덱스를 사용한 원소 접근 ($A[i]$). |
| $O(\log n)$ | **로그 시간** | $n$이 2배 증가하면 실행 시간은 상수만큼 증가. | **이진 탐색** (탐색 범위 절반씩 감소). |
| $O(n)$ | **선형 시간** | $n$에 정비례하여 실행 시간이 증가. | 리스트의 모든 원소 순회 (단일 반복문). |
| $O(n \log n)$ | **로그 선형 시간** | $O(n)$보다는 느리고 $O(n^2)$보다는 빠름. | **병합 정렬**, 힙 정렬. |
| $O(n^2)$ | **2차 시간** | $n$의 제곱에 비례하여 증가. | 이중 반복문을 사용한 모든 쌍 비교 (**선택 정렬**, 버블 정렬). |

---

## 2장: 파이썬 리뷰 (자료구조 구현의 기초 도구)

### 1. 파이썬 컬렉션 자료형

| 자료형 | 표기 | 순서 (Ordering) | 변경 가능성 (Mutability) | 특징 및 구현 용도 |
| :---: | :--- | :--- | :--- | :--- |
| **리스트** (`list`) | `[]` | **O** (인덱스 접근) | **가변 (Mutable)** | 동적 배열. 스택, 큐의 기본 구현체. |
| **딕셔너리** (`dict`) | `{key: value}` | **O** (Python 3.7+부터 입력 순서) | **가변 (Mutable)** | 키-값 쌍 저장. **해시 테이블** 구조, 빠른 검색 $O(1)$. |
| **세트** (`set`) | `{}` 또는 `set()` | **X** (순서 없음) | **가변 (Mutable)** | **중복 불허**. 멤버십 테스트 (원소 존재 확인) $O(1)$. |

### 2. 메모리 및 객체 관리 원리

* **가변/불변 타입:** 가변 타입(list, dict)은 값 변경 시 객체 주소 유지, 불변 타입(tuple, str)은 값 변경 시 새 객체 생성.
* **얕은 복사/깊은 복사:** 가변 객체 복사 시, **얕은 복사**는 내부 객체의 참조를 공유하고, **깊은 복사**는 모든 객체를 완전히 복제한다.

---

## 3장: 리스트와 집합

### 1. 리스트 구현의 효율성 비교

파이썬의 `list`는 내부적으로 **동적 배열**로 구현됩니다.

| 연산 | 배열 리스트의 시간 복잡도 | 연결 리스트의 시간 복잡도 |
| :--- | :--- | :--- |
| **특정 원소 접근/읽기** | $O(1)$ (인덱스 사용) | $O(n)$ (순차적 탐색 필요) |
| **중간 삽입/삭제** | $O(n)$ (뒤쪽 원소 이동 필요) | $O(1)$ (해당 노드를 찾은 후 링크 변경) |
| **특징** | 특정 위치 삽입/삭제가 비효율적인 대신, 임의 접근(Random Access)에 최적화됨. | |

### 2. 집합의 구현과 계산

* **핵심:** 중복 없는 원소 저장 및 빠른 멤버십 테스트.
* **구현 원리:** **해시 테이블**을 사용하여 구현되며, 원소 포함 여부 확인($x$ in $S$)은 평균적으로 **$O(1)$**의 성능을 가진다.

---

## 4장: 스택 (Stack)

### 1. 개념 및 연산 (LIFO)

| 구분 | 설명 | 원리 | 연산 성능 (List 구현 기준) |
| :--- | :--- | :--- | :--- |
| **스택** (Stack ADT) | 한쪽 끝 (**Top**)에서만 데이터를 넣고 뺄 수 있는 선형 자료구조. | **LIFO (Last-In, First-Out)** 후입선출. | |
| **Push** (삽입) | Top에 데이터 추가. | | $O(1)$ (리스트의 `append()`) |
| **Pop** (삭제/반환) | Top의 데이터를 제거하고 반환. | | $O(1)$ (리스트의 `pop()`) |

### 2. 스택의 응용 알고리즘

| 응용 분야 | 스택 활용 원리 |
| :--- | :--- |
| **괄호 검사** | 여는 괄호를 Push, 닫는 괄호를 Pop하여 짝을 맞추고, 최종적으로 스택이 비어있는지 확인. |
| **수식 계산** | 연산자 우선순위를 스택으로 관리하여 **중위 표기식**을 **후위 표기식**으로 변환하거나 계산. |
| **깊이 우선 탐색 (DFS)** | **재귀 호출** 또는 스택을 사용하여 한 경로를 끝까지 탐색하고, 막히면 이전 노드로 돌아가는 과정을 구현. |

---

## 5장: 큐와 덱 (Queue & Deque)

### 1. 큐의 개념 및 효율적 구현 (FIFO)

| 구분 | 설명 | 원리 | 일반 List 큐의 비효율성 | 해결 방안 및 성능 |
| :--- | :--- | :--- | :--- | :--- |
| **큐** (Queue ADT) | 한쪽 끝 (Rear) 삽입, 다른 쪽 끝 (Front) 삭제가 일어나는 선형 자료구조. | **FIFO (First-In, First-Out)** 선입선출. | `Dequeue` 연산(`pop(0)`)이 **$O(n)$**이 됨 (원소 이동). | **원형 큐** 또는 **`collections.deque`**를 사용해 `Dequeue`를 **$O(1)$**로 구현. |

### 2. 덱과 우선순위 큐

| 자료구조 | 특징 | 연산 | 구현 방식 |
| :--- | :--- | :--- | :--- |
| **덱** (Deque) | **양쪽 끝 (앞, 뒤)** 에서 삽입/삭제가 모두 가능한 자료구조. | `add_front()`, `delete_front()`, `add_rear()`, `delete_rear()` | **$O(1)$** 성능을 위해 이중 연결 리스트 기반으로 구현됨. |
| **우선순위 큐** | 우선순위가 높은 데이터부터 먼저 처리되는 큐. | | 주로 **힙 (Heap)** 자료구조를 이용하여 구현하며, 삽입/삭제 시 **$O(\log n)$**의 성능을 가짐. |

### 3. 큐의 응용 알고리즘

* **너비 우선 탐색 (BFS):** **큐**를 사용하여 시작 노드에서 **가까운 노드**부터 순차적으로 탐색을 확장하는 알고리즘. (최단 경로 탐색에 사용)
