## 💻 컴퓨터 비전 핵심 개념 정리 (2주차 ~ 7주차 통합)

### 2주차: 컴퓨터 비전 개요 및 목표

| 주제 | 핵심 개념 | 설명 (정의/의미) |
| :--- | :--- | :--- |
| **컴퓨터 비전 목표** | **강한 인공지능 (Strong AI)** | 일반적인 상황에서 잘 작동하는 인간과 같은 시각 능력을 구현하는 궁극적인 목표. |
| **컴퓨터 비전 목표** | **약한 인공지능 (Weak AI)** | 제한된 환경에서 특정 과업을 높은 성능으로 달성하는 **현실적인 목표** (현재 컴퓨터 비전의 주류). |
| **주요 과제** | **분류 (Classification)** | 영상이 어떤 카테고리(클래스)에 속하는지 판별하는 문제. |
| **주요 과제** | **검출 (Detection)** | 영상 내에서 객체의 위치를 찾아 **바운딩 박스**로 표시하는 문제. |
| **주요 과제** | **분할 (Segmentation)** | 영상의 픽셀들을 객체나 영역별로 분리하는 문제. |
| **주요 과제** | **추적 (Tracking)** | 영상 내에서 특정 객체의 움직임을 연속적으로 따라가는 문제. |

---

### 3주차: OpenCV 및 영상 입출력

| 주제 | 핵심 개념 | 설명 (정의/의미) |
| :--- | :--- | :--- |
| **OpenCV 기본** | **Numpy.ndarray** | OpenCV에서 이미지를 표현하는 **기본 자료구조**로, 픽셀 데이터를 **다차원 배열**로 저장함. |
| **영상 읽기** | **cv.imread()** | 파일로부터 **이미지(영상)**를 읽어와 Numpy 배열 형태로 반환하는 함수. |
| **영상 출력** | **cv.imshow()** | 윈도우 창에 이미지를 출력하는 함수. |
| **영상 캡처** | **cv.VideoCapture()** | **웹캠**이나 **비디오 파일**로부터 연속적인 **프레임**을 획득하고 처리하기 위해 사용하는 함수. |
| **사용자 인터페이스** | **cv.line(), cv.circle()** | 영상에 **도형**이나 **글자**를 넣는 등 그래픽 기능을 구현하는 데 사용되는 함수. |

---

### 4주차: 디지털 영상 및 기본 연산

| 주제 | 핵심 개념 | 설명 (정의/의미) |
| :--- | :--- | :--- |
| **디지털 영상** | **픽셀 (Pixel)** | 디지털 영상을 구성하는 **최소 단위의 점**으로, 명암도(밝기)나 색상 정보를 가짐. |
| **영상 연산 구분** | **점 연산 (Point Operation)** | 결과 픽셀 값이 **원본 영상의 같은 위치 픽셀 하나**만 참조하여 결정되는 연산. |
| **영상 연산 구분** | **영역 연산 (Area Operation)** | 결과 픽셀 값이 **주변 이웃 화소들**의 값들을 참조하여 결정되는 연산 (예: 블러, 에지 검출). |
| **영상 연산 구분** | **기하 연산 (Geometric Operation)** | 좌표 변환을 통해 이미지의 **위치나 형태**를 바꾸는 연산 (예: 이동, 회전, 크기 변경). |
| **이진 영상** | **임계값 처리 (Thresholding)** | 픽셀 값을 특정 **임계값(T)**을 기준으로 흑(0) 또는 백(255)으로 나누어 이진 영상을 만드는 처리. |
| **모폴로지 연산** | **침식 (Erosion)** | 전경(흰색) 영역의 경계선을 **축소**시켜 작은 잡음을 제거하는 연산. |
| **모폴로지 연산** | **팽창 (Dilation)** | 전경(흰색) 영역의 경계선을 **확대**시켜 구멍을 채우거나 끊어진 선을 연결하는 연산. |

---

### 5주차: 영역 연산, 기하 연산 및 에지/분할

| 주제 | 핵심 개념 | 설명 (정의/의미) |
| :--- | :--- | :--- |
| **영역 연산** | **컨볼루션 (Convolution)** | 영역 연산의 주된 방식. **커널(필터)**을 이미지에 슬라이딩하며 곱하고 더해 특징을 추출하는 연산. |
| **기하 연산** | **동차 좌표 (Homogeneous Coordinate)** | **이동, 회전, 크기 변경** 등 모든 기하 변환을 **하나의 행렬 곱셈**으로 통합하여 처리하기 위해 사용하는 좌표계. |
| **기하 연산** | **영상 보간 (Interpolation)** | 크기 변경 시, **존재하지 않는 새로운 픽셀의 값**을 주변 픽셀들의 정보를 바탕으로 추정해 채워 넣는 과정. |
| **보간 방법** | **최근접 이웃 보간** | 가장 가까운 픽셀 값을 그대로 복사해서 사용 (빠르지만 계단 현상 발생 가능). |
| **보간 방법** | **양선형 보간 (Bilinear Interpolation)** | 주변 **4개의 픽셀 값**을 선형적으로 가중 평균하여 새로운 픽셀 값을 계산 (화질이 부드러움). |
| **에지 검출** | **캐니 에지 (Canny Edge)** | **잡음에 강인**하고, **단일 픽셀 폭**을 가진 실제 에지만을 검출하는 **최적의 에지 검출** 알고리즘. |
| **영역 분할** | **Active Contour (Snake)** | 사용자가 그린 초기 곡선을 **객체의 실제 경계선**에 맞게 자동으로 수축/팽창시켜 윤곽선을 찾아주는 방법. |
| **영역 분할** | **GrabCut 알고리즘** | 사용자가 지정한 영역을 바탕으로 객체와 배경의 **히스토그램**을 분석하여 영역을 자동으로 분리하는 대화식 분할 방법. |

---

### 6주차 & 7주차: 지역 특징 및 매칭

| 주제 | 핵심 개념 | 설명 (정의/의미) |
| :--- | :--- | :--- |
| **특징 기반 분석** | **대응점 문제 (Correspondence Problem)** | 서로 다른 영상에서 **같은 물체의 같은 지점**을 정확하게 찾아내는 문제. |
| **특징 기반 분석** | **지역 특징 (Local Feature)** | 영상의 작은 영역에서 추출된 특징으로, **조명, 회전, 크기 변화**에 **강인**하도록 설계된 해결책. |
| **지역 특징** | **SIFT (Scale-Invariant Feature Transform)** | **크기(Scale)와 회전(Rotation)**에 **불변**하도록 설계된 지역 특징 추출 알고리즘. |
| **지역 특징 요소** | **기술자 (Descriptor)** | 특징점 주변의 정보를 **수치 벡터**로 요약한 것으로, 서로 다른 특징점의 유사도를 비교하는 데 사용. |
| **매칭** | **최근접 이웃 매칭** | 기술자 간의 거리를 계산하여 **가장 가까운 특징점**을 대응점으로 결정하는 매칭 방법. |
| **매칭 성능 지표** | **ROC 곡선** | T값을 바꾸며 생기는 **TPR(민감도)**과 **FPR(오탐율)**의 변화를 그래프로 나타낸 것. |
| **매칭 성능 지표** | **AUC (Area Under Curve)** | ROC 곡선 아래의 면적으로, 매칭 알고리즘의 **전체 성능**을 수치로 나타낸 지표 (높을수록 좋음). |
| **매칭 변환** | **호모그래피 (Homography)** | **두 평면(plane) 사이의 좌표 변환** 관계를 나타내는 3x3 행렬. 한 평면을 다른 평면으로 투영하는 데 사용됨. |


## 💻 컴퓨터 비전 핵심 코드 분석 (2주차 ~ 7주차)

# ==============================================================================
# 2주차: 컴퓨터 비전 개요 및 목표
# ==============================================================================

# 컴퓨터 비전 주요 과제 정의 및 목표 (코드 상수화)
TASK_CLASSIFICATION = "Image -> Single Label"          # # 주석: 이미지가 속한 카테고리(레이블) 판별
TASK_DETECTION = "Image -> Bounding Box + Label"       # # 주석: 이미지 내 객체의 위치(좌표)와 종류 판별
TASK_SEGMENTATION = "Image -> Pixel-wise Label Map"    # # 주석: 모든 픽셀을 객체/영역별로 분할 (가장 세밀한 목표)

# ==============================================================================
# 3주차: OpenCV 및 영상 입출력
# ==============================================================================

# 3-1. 이미지 파일 읽기 및 표시 (OpenCV 기본 I/O)
def cv_image_read_show(file_path):
    # # 주석: cv.imread()는 이미지를 numpy.ndarray 형태로 반환 (기본 BGR 채널 순서)
    image = cv.imread(file_path)
    if image is None: 
        print("Image Not Found")
        return
    cv.imshow("Window Name", image)
    cv.waitKey(0) # # 주석: 키 입력 대기 (0은 무한 대기)
    cv.destroyAllWindows()
    return image

# 3-2. 영상 캡처 및 프레임 처리 (비디오/웹캠)
def cv_video_capture(source_id=0):
    cap = cv.VideoCapture(source_id) # # 주석: 웹캠(0) 또는 파일 경로로 비디오 스트림 연결
    while cap.isOpened():
        ret, frame = cap.read()      # # 주석: 비디오에서 한 프레임을 읽음 (ret: 성공 여부)
        if not ret: break
        cv.imshow("Video Frame", frame)
        if cv.waitKey(1) & 0xFF == ord('q'): # # 주석: 1ms마다 대기하며 'q' 입력 시 종료
            break
    cap.release()

# ==============================================================================
# 4주차: 디지털 영상 및 기본 연산 (점 연산, 모폴로지)
# ==============================================================================

# 4-1. 이진 영상 임계값 처리 (Thresholding)
def thresholding(pixel_value, T=127):
    # # 주석: 임계값(T)을 기준으로 픽셀 값을 흑(0) 또는 백(255)으로 이진화 (점 연산의 대표 예시)
    return 255 if pixel_value > T else 0

# 4-2. 모폴로지 연산: 침식 (Erosion)의 기본 원리
def erode_core(binary_image, kernel):
    # # 주석: 커널 영역 내 모든 픽셀이 1(전경)일 때만 중심 픽셀을 1로 유지 (전경 영역 축소)
    new_image = zeros_like(binary_image)
    for i, j in image_pixels:
        if all(image[i+x, j+y] == 1 for x, y in kernel_coords):
            new_image[i, j] = 1
    return new_image

# 4-3. 모폴로지 연산: 팽창 (Dilation)의 기본 원리
def dilate_core(binary_image, kernel):
    # # 주석: 커널 영역 내 픽셀 중 하나라도 1(전경)이면 중심 픽셀을 1로 만듦 (전경 영역 확대/구멍 채우기)
    new_image = zeros_like(binary_image)
    for i, j in image_pixels:
        if any(image[i+x, j+y] == 1 for x, y in kernel_coords):
            new_image[i, j] = 1
    return new_image

# ==============================================================================
# 5주차: 영역 연산, 기하 연산 및 에지/분할
# ==============================================================================

# 5-1. 합성곱 (Convolution)의 핵심 연산 (영역 연산의 기본)
def convolution_core(image_patch, kernel):
    # # 주석: 이미지 패치와 커널을 원소별 곱셈 후, 모든 결과를 합산하여 출력 픽셀 값 결정
    return sum(image_patch * kernel)

# 5-2. 컨볼루션/풀링 층의 출력 크기 계산 공식
def calculate_output_size(H_in, F, P=0, S=1):
    # # 주석: (입력 크기 - 필터 크기 + 2 * 패딩) / 스트라이드 + 1
    H_out = (H_in - F + 2 * P) // S + 1 
    return H_out

# 5-3. 기하 연산: 동차 좌표를 이용한 이동 (Translation Matrix)
def translation_matrix(tx, ty):
    # # 주석: 이동(tx, ty)을 하나의 행렬 곱셈으로 표현. 다른 변환과 결합 가능
    M = [[1, 0, tx],
         [0, 1, ty],
         [0, 0, 1]]
    return M

# 5-4. 양선형 보간 (Bilinear Interpolation)
def bilinear_interpolation(p1, p2, p3, p4, a, b):
    # # 주석: 주변 4개 픽셀(p1~p4)을 가중 평균하여 새로운 픽셀 값 추정 (a, b는 가중치/거리)
    # p1(0,0), p2(1,0), p3(0,1), p4(1,1)
    value = (1-a)*(1-b)*p1 + a*(1-b)*p2 + (1-a)*b*p3 + a*b*p4
    return value

# 5-5. 에지 검출: 캐니 에지 (Canny Edge)의 4단계 (프로세스 순서)
CANNY_STEPS = [
    "1. Gaussian Blur (잡음 제거)",
    "2. Gradient Calculation (명암 변화율/방향 계산)",
    "3. Non-Maximum Suppression (가장 강한 에지만 선택)",
    "4. Hysteresis Thresholding (이력 임계값으로 최종 에지 연결)" # # 주석: 약한 에지를 연결하여 에지 완성
]

# ==============================================================================
# 6주차 & 7주차: 지역 특징 및 매칭 (SIFT, Homography)
# ==============================================================================

# 6-1. SIFT 특징점 기술자 (Descriptor) 생성 원리
SIFT_DESCRIPTOR_CORE = "Keypoint Orientation Histograms" # # 주석: 특징점 주변 영역의 방향 히스토그램을 추출하여 128차원 벡터로 변환 (크기/회전 불변성 확보)

# 6-2. 매칭 필터링: 최근접 거리 비율 (Nearest Neighbor Distance Ratio Test)
def distance_ratio_test(dist_nn1, dist_nn2, threshold=0.7):
    # # 주석: 가장 가까운 특징점(NN1)과 두 번째 가까운 특징점(NN2)의 거리 비율을 비교하여 오매칭 제거
    if dist_nn1 / dist_nn2 < threshold:
        return True # 매칭으로 인정 (유효한 매칭)
    return False # # 주석: 비율이 크면 모호한 특징이므로 오매칭으로 간주

# 6-3. 호모그래피 (Homography) 행렬 공식
HOMOGRAPHY_MATRIX = """
p' ≈ H * p  (3x3 행렬)
# # 주석: 원본 평면 좌표 p (동차좌표 (x, y, 1)T)를 호모그래피 행렬 H를 곱하여 변환된 평면 좌표 p'로 사상함
H = [[h11, h12, h13],
     [h21, h22, h23],
     [h31, h32, h33]]
"""

# 6-4. 호모그래피 추정 알고리즘 (RANSAC 기반)
def estimate_homography(good_matches):
    # # 주석: RANSAC (Random Sample Consensus) 알고리즘을 사용하여 매칭 쌍에서 이상치(Outlier)를 제거
    # # 주석: 최종적으로 가장 많은 내부점(Inlier)을 포함하는 최적의 호모그래피 행렬 H를 추정
    H_matrix, mask = cv.findHomography(good_matches, method='RANSAC')
    return H_matrix
