## ğŸ’» ì»´í“¨í„° ë¹„ì „ í•µì‹¬ ê°œë… ì •ë¦¬ (2ì£¼ì°¨ ~ 7ì£¼ì°¨ í†µí•©)

### 2ì£¼ì°¨: ì»´í“¨í„° ë¹„ì „ ê°œìš” ë° ëª©í‘œ

| ì£¼ì œ | í•µì‹¬ ê°œë… | ì„¤ëª… (ì •ì˜/ì˜ë¯¸) |
| :--- | :--- | :--- |
| **ì»´í“¨í„° ë¹„ì „ ëª©í‘œ** | **ê°•í•œ ì¸ê³µì§€ëŠ¥ (Strong AI)** | ì¼ë°˜ì ì¸ ìƒí™©ì—ì„œ ì˜ ì‘ë™í•˜ëŠ” ì¸ê°„ê³¼ ê°™ì€ ì‹œê° ëŠ¥ë ¥ì„ êµ¬í˜„í•˜ëŠ” ê¶ê·¹ì ì¸ ëª©í‘œ. |
| **ì»´í“¨í„° ë¹„ì „ ëª©í‘œ** | **ì•½í•œ ì¸ê³µì§€ëŠ¥ (Weak AI)** | ì œí•œëœ í™˜ê²½ì—ì„œ íŠ¹ì • ê³¼ì—…ì„ ë†’ì€ ì„±ëŠ¥ìœ¼ë¡œ ë‹¬ì„±í•˜ëŠ” **í˜„ì‹¤ì ì¸ ëª©í‘œ** (í˜„ì¬ ì»´í“¨í„° ë¹„ì „ì˜ ì£¼ë¥˜). |
| **ì£¼ìš” ê³¼ì œ** | **ë¶„ë¥˜ (Classification)** | ì˜ìƒì´ ì–´ë–¤ ì¹´í…Œê³ ë¦¬(í´ë˜ìŠ¤)ì— ì†í•˜ëŠ”ì§€ íŒë³„í•˜ëŠ” ë¬¸ì œ. |
| **ì£¼ìš” ê³¼ì œ** | **ê²€ì¶œ (Detection)** | ì˜ìƒ ë‚´ì—ì„œ ê°ì²´ì˜ ìœ„ì¹˜ë¥¼ ì°¾ì•„ **ë°”ìš´ë”© ë°•ìŠ¤**ë¡œ í‘œì‹œí•˜ëŠ” ë¬¸ì œ. |
| **ì£¼ìš” ê³¼ì œ** | **ë¶„í•  (Segmentation)** | ì˜ìƒì˜ í”½ì…€ë“¤ì„ ê°ì²´ë‚˜ ì˜ì—­ë³„ë¡œ ë¶„ë¦¬í•˜ëŠ” ë¬¸ì œ. |
| **ì£¼ìš” ê³¼ì œ** | **ì¶”ì  (Tracking)** | ì˜ìƒ ë‚´ì—ì„œ íŠ¹ì • ê°ì²´ì˜ ì›€ì§ì„ì„ ì—°ì†ì ìœ¼ë¡œ ë”°ë¼ê°€ëŠ” ë¬¸ì œ. |

---

### 3ì£¼ì°¨: OpenCV ë° ì˜ìƒ ì…ì¶œë ¥

| ì£¼ì œ | í•µì‹¬ ê°œë… | ì„¤ëª… (ì •ì˜/ì˜ë¯¸) |
| :--- | :--- | :--- |
| **OpenCV ê¸°ë³¸** | **Numpy.ndarray** | OpenCVì—ì„œ ì´ë¯¸ì§€ë¥¼ í‘œí˜„í•˜ëŠ” **ê¸°ë³¸ ìë£Œêµ¬ì¡°**ë¡œ, í”½ì…€ ë°ì´í„°ë¥¼ **ë‹¤ì°¨ì› ë°°ì—´**ë¡œ ì €ì¥í•¨. |
| **ì˜ìƒ ì½ê¸°** | **cv.imread()** | íŒŒì¼ë¡œë¶€í„° **ì´ë¯¸ì§€(ì˜ìƒ)**ë¥¼ ì½ì–´ì™€ Numpy ë°°ì—´ í˜•íƒœë¡œ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜. |
| **ì˜ìƒ ì¶œë ¥** | **cv.imshow()** | ìœˆë„ìš° ì°½ì— ì´ë¯¸ì§€ë¥¼ ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜. |
| **ì˜ìƒ ìº¡ì²˜** | **cv.VideoCapture()** | **ì›¹ìº **ì´ë‚˜ **ë¹„ë””ì˜¤ íŒŒì¼**ë¡œë¶€í„° ì—°ì†ì ì¸ **í”„ë ˆì„**ì„ íšë“í•˜ê³  ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜. |
| **ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤** | **cv.line(), cv.circle()** | ì˜ìƒì— **ë„í˜•**ì´ë‚˜ **ê¸€ì**ë¥¼ ë„£ëŠ” ë“± ê·¸ë˜í”½ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜. |

---

### 4ì£¼ì°¨: ë””ì§€í„¸ ì˜ìƒ ë° ê¸°ë³¸ ì—°ì‚°

| ì£¼ì œ | í•µì‹¬ ê°œë… | ì„¤ëª… (ì •ì˜/ì˜ë¯¸) |
| :--- | :--- | :--- |
| **ë””ì§€í„¸ ì˜ìƒ** | **í”½ì…€ (Pixel)** | ë””ì§€í„¸ ì˜ìƒì„ êµ¬ì„±í•˜ëŠ” **ìµœì†Œ ë‹¨ìœ„ì˜ ì **ìœ¼ë¡œ, ëª…ì•”ë„(ë°ê¸°)ë‚˜ ìƒ‰ìƒ ì •ë³´ë¥¼ ê°€ì§. |
| **ì˜ìƒ ì—°ì‚° êµ¬ë¶„** | **ì  ì—°ì‚° (Point Operation)** | ê²°ê³¼ í”½ì…€ ê°’ì´ **ì›ë³¸ ì˜ìƒì˜ ê°™ì€ ìœ„ì¹˜ í”½ì…€ í•˜ë‚˜**ë§Œ ì°¸ì¡°í•˜ì—¬ ê²°ì •ë˜ëŠ” ì—°ì‚°. |
| **ì˜ìƒ ì—°ì‚° êµ¬ë¶„** | **ì˜ì—­ ì—°ì‚° (Area Operation)** | ê²°ê³¼ í”½ì…€ ê°’ì´ **ì£¼ë³€ ì´ì›ƒ í™”ì†Œë“¤**ì˜ ê°’ë“¤ì„ ì°¸ì¡°í•˜ì—¬ ê²°ì •ë˜ëŠ” ì—°ì‚° (ì˜ˆ: ë¸”ëŸ¬, ì—ì§€ ê²€ì¶œ). |
| **ì˜ìƒ ì—°ì‚° êµ¬ë¶„** | **ê¸°í•˜ ì—°ì‚° (Geometric Operation)** | ì¢Œí‘œ ë³€í™˜ì„ í†µí•´ ì´ë¯¸ì§€ì˜ **ìœ„ì¹˜ë‚˜ í˜•íƒœ**ë¥¼ ë°”ê¾¸ëŠ” ì—°ì‚° (ì˜ˆ: ì´ë™, íšŒì „, í¬ê¸° ë³€ê²½). |
| **ì´ì§„ ì˜ìƒ** | **ì„ê³„ê°’ ì²˜ë¦¬ (Thresholding)** | í”½ì…€ ê°’ì„ íŠ¹ì • **ì„ê³„ê°’(T)**ì„ ê¸°ì¤€ìœ¼ë¡œ í‘(0) ë˜ëŠ” ë°±(255)ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì´ì§„ ì˜ìƒì„ ë§Œë“œëŠ” ì²˜ë¦¬. |
| **ëª¨í´ë¡œì§€ ì—°ì‚°** | **ì¹¨ì‹ (Erosion)** | ì „ê²½(í°ìƒ‰) ì˜ì—­ì˜ ê²½ê³„ì„ ì„ **ì¶•ì†Œ**ì‹œì¼œ ì‘ì€ ì¡ìŒì„ ì œê±°í•˜ëŠ” ì—°ì‚°. |
| **ëª¨í´ë¡œì§€ ì—°ì‚°** | **íŒ½ì°½ (Dilation)** | ì „ê²½(í°ìƒ‰) ì˜ì—­ì˜ ê²½ê³„ì„ ì„ **í™•ëŒ€**ì‹œì¼œ êµ¬ë©ì„ ì±„ìš°ê±°ë‚˜ ëŠì–´ì§„ ì„ ì„ ì—°ê²°í•˜ëŠ” ì—°ì‚°. |

---

### 5ì£¼ì°¨: ì˜ì—­ ì—°ì‚°, ê¸°í•˜ ì—°ì‚° ë° ì—ì§€/ë¶„í• 

| ì£¼ì œ | í•µì‹¬ ê°œë… | ì„¤ëª… (ì •ì˜/ì˜ë¯¸) |
| :--- | :--- | :--- |
| **ì˜ì—­ ì—°ì‚°** | **ì»¨ë³¼ë£¨ì…˜ (Convolution)** | ì˜ì—­ ì—°ì‚°ì˜ ì£¼ëœ ë°©ì‹. **ì»¤ë„(í•„í„°)**ì„ ì´ë¯¸ì§€ì— ìŠ¬ë¼ì´ë”©í•˜ë©° ê³±í•˜ê³  ë”í•´ íŠ¹ì§•ì„ ì¶”ì¶œí•˜ëŠ” ì—°ì‚°. |
| **ê¸°í•˜ ì—°ì‚°** | **ë™ì°¨ ì¢Œí‘œ (Homogeneous Coordinate)** | **ì´ë™, íšŒì „, í¬ê¸° ë³€ê²½** ë“± ëª¨ë“  ê¸°í•˜ ë³€í™˜ì„ **í•˜ë‚˜ì˜ í–‰ë ¬ ê³±ì…ˆ**ìœ¼ë¡œ í†µí•©í•˜ì—¬ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ì¢Œí‘œê³„. |
| **ê¸°í•˜ ì—°ì‚°** | **ì˜ìƒ ë³´ê°„ (Interpolation)** | í¬ê¸° ë³€ê²½ ì‹œ, **ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ìƒˆë¡œìš´ í”½ì…€ì˜ ê°’**ì„ ì£¼ë³€ í”½ì…€ë“¤ì˜ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì¶”ì •í•´ ì±„ì›Œ ë„£ëŠ” ê³¼ì •. |
| **ë³´ê°„ ë°©ë²•** | **ìµœê·¼ì ‘ ì´ì›ƒ ë³´ê°„** | ê°€ì¥ ê°€ê¹Œìš´ í”½ì…€ ê°’ì„ ê·¸ëŒ€ë¡œ ë³µì‚¬í•´ì„œ ì‚¬ìš© (ë¹ ë¥´ì§€ë§Œ ê³„ë‹¨ í˜„ìƒ ë°œìƒ ê°€ëŠ¥). |
| **ë³´ê°„ ë°©ë²•** | **ì–‘ì„ í˜• ë³´ê°„ (Bilinear Interpolation)** | ì£¼ë³€ **4ê°œì˜ í”½ì…€ ê°’**ì„ ì„ í˜•ì ìœ¼ë¡œ ê°€ì¤‘ í‰ê· í•˜ì—¬ ìƒˆë¡œìš´ í”½ì…€ ê°’ì„ ê³„ì‚° (í™”ì§ˆì´ ë¶€ë“œëŸ¬ì›€). |
| **ì—ì§€ ê²€ì¶œ** | **ìºë‹ˆ ì—ì§€ (Canny Edge)** | **ì¡ìŒì— ê°•ì¸**í•˜ê³ , **ë‹¨ì¼ í”½ì…€ í­**ì„ ê°€ì§„ ì‹¤ì œ ì—ì§€ë§Œì„ ê²€ì¶œí•˜ëŠ” **ìµœì ì˜ ì—ì§€ ê²€ì¶œ** ì•Œê³ ë¦¬ì¦˜. |
| **ì˜ì—­ ë¶„í• ** | **Active Contour (Snake)** | ì‚¬ìš©ìê°€ ê·¸ë¦° ì´ˆê¸° ê³¡ì„ ì„ **ê°ì²´ì˜ ì‹¤ì œ ê²½ê³„ì„ **ì— ë§ê²Œ ìë™ìœ¼ë¡œ ìˆ˜ì¶•/íŒ½ì°½ì‹œì¼œ ìœ¤ê³½ì„ ì„ ì°¾ì•„ì£¼ëŠ” ë°©ë²•. |
| **ì˜ì—­ ë¶„í• ** | **GrabCut ì•Œê³ ë¦¬ì¦˜** | ì‚¬ìš©ìê°€ ì§€ì •í•œ ì˜ì—­ì„ ë°”íƒ•ìœ¼ë¡œ ê°ì²´ì™€ ë°°ê²½ì˜ **íˆìŠ¤í† ê·¸ë¨**ì„ ë¶„ì„í•˜ì—¬ ì˜ì—­ì„ ìë™ìœ¼ë¡œ ë¶„ë¦¬í•˜ëŠ” ëŒ€í™”ì‹ ë¶„í•  ë°©ë²•. |

---

### 6ì£¼ì°¨ & 7ì£¼ì°¨: ì§€ì—­ íŠ¹ì§• ë° ë§¤ì¹­

| ì£¼ì œ | í•µì‹¬ ê°œë… | ì„¤ëª… (ì •ì˜/ì˜ë¯¸) |
| :--- | :--- | :--- |
| **íŠ¹ì§• ê¸°ë°˜ ë¶„ì„** | **ëŒ€ì‘ì  ë¬¸ì œ (Correspondence Problem)** | ì„œë¡œ ë‹¤ë¥¸ ì˜ìƒì—ì„œ **ê°™ì€ ë¬¼ì²´ì˜ ê°™ì€ ì§€ì **ì„ ì •í™•í•˜ê²Œ ì°¾ì•„ë‚´ëŠ” ë¬¸ì œ. |
| **íŠ¹ì§• ê¸°ë°˜ ë¶„ì„** | **ì§€ì—­ íŠ¹ì§• (Local Feature)** | ì˜ìƒì˜ ì‘ì€ ì˜ì—­ì—ì„œ ì¶”ì¶œëœ íŠ¹ì§•ìœ¼ë¡œ, **ì¡°ëª…, íšŒì „, í¬ê¸° ë³€í™”**ì— **ê°•ì¸**í•˜ë„ë¡ ì„¤ê³„ëœ í•´ê²°ì±…. |
| **ì§€ì—­ íŠ¹ì§•** | **SIFT (Scale-Invariant Feature Transform)** | **í¬ê¸°(Scale)ì™€ íšŒì „(Rotation)**ì— **ë¶ˆë³€**í•˜ë„ë¡ ì„¤ê³„ëœ ì§€ì—­ íŠ¹ì§• ì¶”ì¶œ ì•Œê³ ë¦¬ì¦˜. |
| **ì§€ì—­ íŠ¹ì§• ìš”ì†Œ** | **ê¸°ìˆ ì (Descriptor)** | íŠ¹ì§•ì  ì£¼ë³€ì˜ ì •ë³´ë¥¼ **ìˆ˜ì¹˜ ë²¡í„°**ë¡œ ìš”ì•½í•œ ê²ƒìœ¼ë¡œ, ì„œë¡œ ë‹¤ë¥¸ íŠ¹ì§•ì ì˜ ìœ ì‚¬ë„ë¥¼ ë¹„êµí•˜ëŠ” ë° ì‚¬ìš©. |
| **ë§¤ì¹­** | **ìµœê·¼ì ‘ ì´ì›ƒ ë§¤ì¹­** | ê¸°ìˆ ì ê°„ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ì—¬ **ê°€ì¥ ê°€ê¹Œìš´ íŠ¹ì§•ì **ì„ ëŒ€ì‘ì ìœ¼ë¡œ ê²°ì •í•˜ëŠ” ë§¤ì¹­ ë°©ë²•. |
| **ë§¤ì¹­ ì„±ëŠ¥ ì§€í‘œ** | **ROC ê³¡ì„ ** | Tê°’ì„ ë°”ê¾¸ë©° ìƒê¸°ëŠ” **TPR(ë¯¼ê°ë„)**ê³¼ **FPR(ì˜¤íƒìœ¨)**ì˜ ë³€í™”ë¥¼ ê·¸ë˜í”„ë¡œ ë‚˜íƒ€ë‚¸ ê²ƒ. |
| **ë§¤ì¹­ ì„±ëŠ¥ ì§€í‘œ** | **AUC (Area Under Curve)** | ROC ê³¡ì„  ì•„ë˜ì˜ ë©´ì ìœ¼ë¡œ, ë§¤ì¹­ ì•Œê³ ë¦¬ì¦˜ì˜ **ì „ì²´ ì„±ëŠ¥**ì„ ìˆ˜ì¹˜ë¡œ ë‚˜íƒ€ë‚¸ ì§€í‘œ (ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ). |
| **ë§¤ì¹­ ë³€í™˜** | **í˜¸ëª¨ê·¸ë˜í”¼ (Homography)** | **ë‘ í‰ë©´(plane) ì‚¬ì´ì˜ ì¢Œí‘œ ë³€í™˜** ê´€ê³„ë¥¼ ë‚˜íƒ€ë‚´ëŠ” 3x3 í–‰ë ¬. í•œ í‰ë©´ì„ ë‹¤ë¥¸ í‰ë©´ìœ¼ë¡œ íˆ¬ì˜í•˜ëŠ” ë° ì‚¬ìš©ë¨. |


## ğŸ’» ì»´í“¨í„° ë¹„ì „ í•µì‹¬ ì½”ë“œ ë¶„ì„ (2ì£¼ì°¨ ~ 7ì£¼ì°¨)

# ==============================================================================
# 2ì£¼ì°¨: ì»´í“¨í„° ë¹„ì „ ê°œìš” ë° ëª©í‘œ
# ==============================================================================

# ì»´í“¨í„° ë¹„ì „ ì£¼ìš” ê³¼ì œ ì •ì˜ ë° ëª©í‘œ (ì½”ë“œ ìƒìˆ˜í™”)
TASK_CLASSIFICATION = "Image -> Single Label"          # # ì£¼ì„: ì´ë¯¸ì§€ê°€ ì†í•œ ì¹´í…Œê³ ë¦¬(ë ˆì´ë¸”) íŒë³„
TASK_DETECTION = "Image -> Bounding Box + Label"       # # ì£¼ì„: ì´ë¯¸ì§€ ë‚´ ê°ì²´ì˜ ìœ„ì¹˜(ì¢Œí‘œ)ì™€ ì¢…ë¥˜ íŒë³„
TASK_SEGMENTATION = "Image -> Pixel-wise Label Map"    # # ì£¼ì„: ëª¨ë“  í”½ì…€ì„ ê°ì²´/ì˜ì—­ë³„ë¡œ ë¶„í•  (ê°€ì¥ ì„¸ë°€í•œ ëª©í‘œ)

# ==============================================================================
# 3ì£¼ì°¨: OpenCV ë° ì˜ìƒ ì…ì¶œë ¥
# ==============================================================================

# 3-1. ì´ë¯¸ì§€ íŒŒì¼ ì½ê¸° ë° í‘œì‹œ (OpenCV ê¸°ë³¸ I/O)
def cv_image_read_show(file_path):
    # # ì£¼ì„: cv.imread()ëŠ” ì´ë¯¸ì§€ë¥¼ numpy.ndarray í˜•íƒœë¡œ ë°˜í™˜ (ê¸°ë³¸ BGR ì±„ë„ ìˆœì„œ)
    image = cv.imread(file_path)
    if image is None: 
        print("Image Not Found")
        return
    cv.imshow("Window Name", image)
    cv.waitKey(0) # # ì£¼ì„: í‚¤ ì…ë ¥ ëŒ€ê¸° (0ì€ ë¬´í•œ ëŒ€ê¸°)
    cv.destroyAllWindows()
    return image

# 3-2. ì˜ìƒ ìº¡ì²˜ ë° í”„ë ˆì„ ì²˜ë¦¬ (ë¹„ë””ì˜¤/ì›¹ìº )
def cv_video_capture(source_id=0):
    cap = cv.VideoCapture(source_id) # # ì£¼ì„: ì›¹ìº (0) ë˜ëŠ” íŒŒì¼ ê²½ë¡œë¡œ ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ì—°ê²°
    while cap.isOpened():
        ret, frame = cap.read()      # # ì£¼ì„: ë¹„ë””ì˜¤ì—ì„œ í•œ í”„ë ˆì„ì„ ì½ìŒ (ret: ì„±ê³µ ì—¬ë¶€)
        if not ret: break
        cv.imshow("Video Frame", frame)
        if cv.waitKey(1) & 0xFF == ord('q'): # # ì£¼ì„: 1msë§ˆë‹¤ ëŒ€ê¸°í•˜ë©° 'q' ì…ë ¥ ì‹œ ì¢…ë£Œ
            break
    cap.release()

# ==============================================================================
# 4ì£¼ì°¨: ë””ì§€í„¸ ì˜ìƒ ë° ê¸°ë³¸ ì—°ì‚° (ì  ì—°ì‚°, ëª¨í´ë¡œì§€)
# ==============================================================================

# 4-1. ì´ì§„ ì˜ìƒ ì„ê³„ê°’ ì²˜ë¦¬ (Thresholding)
def thresholding(pixel_value, T=127):
    # # ì£¼ì„: ì„ê³„ê°’(T)ì„ ê¸°ì¤€ìœ¼ë¡œ í”½ì…€ ê°’ì„ í‘(0) ë˜ëŠ” ë°±(255)ìœ¼ë¡œ ì´ì§„í™” (ì  ì—°ì‚°ì˜ ëŒ€í‘œ ì˜ˆì‹œ)
    return 255 if pixel_value > T else 0

# 4-2. ëª¨í´ë¡œì§€ ì—°ì‚°: ì¹¨ì‹ (Erosion)ì˜ ê¸°ë³¸ ì›ë¦¬
def erode_core(binary_image, kernel):
    # # ì£¼ì„: ì»¤ë„ ì˜ì—­ ë‚´ ëª¨ë“  í”½ì…€ì´ 1(ì „ê²½)ì¼ ë•Œë§Œ ì¤‘ì‹¬ í”½ì…€ì„ 1ë¡œ ìœ ì§€ (ì „ê²½ ì˜ì—­ ì¶•ì†Œ)
    new_image = zeros_like(binary_image)
    for i, j in image_pixels:
        if all(image[i+x, j+y] == 1 for x, y in kernel_coords):
            new_image[i, j] = 1
    return new_image

# 4-3. ëª¨í´ë¡œì§€ ì—°ì‚°: íŒ½ì°½ (Dilation)ì˜ ê¸°ë³¸ ì›ë¦¬
def dilate_core(binary_image, kernel):
    # # ì£¼ì„: ì»¤ë„ ì˜ì—­ ë‚´ í”½ì…€ ì¤‘ í•˜ë‚˜ë¼ë„ 1(ì „ê²½)ì´ë©´ ì¤‘ì‹¬ í”½ì…€ì„ 1ë¡œ ë§Œë“¦ (ì „ê²½ ì˜ì—­ í™•ëŒ€/êµ¬ë© ì±„ìš°ê¸°)
    new_image = zeros_like(binary_image)
    for i, j in image_pixels:
        if any(image[i+x, j+y] == 1 for x, y in kernel_coords):
            new_image[i, j] = 1
    return new_image

# ==============================================================================
# 5ì£¼ì°¨: ì˜ì—­ ì—°ì‚°, ê¸°í•˜ ì—°ì‚° ë° ì—ì§€/ë¶„í• 
# ==============================================================================

# 5-1. í•©ì„±ê³± (Convolution)ì˜ í•µì‹¬ ì—°ì‚° (ì˜ì—­ ì—°ì‚°ì˜ ê¸°ë³¸)
def convolution_core(image_patch, kernel):
    # # ì£¼ì„: ì´ë¯¸ì§€ íŒ¨ì¹˜ì™€ ì»¤ë„ì„ ì›ì†Œë³„ ê³±ì…ˆ í›„, ëª¨ë“  ê²°ê³¼ë¥¼ í•©ì‚°í•˜ì—¬ ì¶œë ¥ í”½ì…€ ê°’ ê²°ì •
    return sum(image_patch * kernel)

# 5-2. ì»¨ë³¼ë£¨ì…˜/í’€ë§ ì¸µì˜ ì¶œë ¥ í¬ê¸° ê³„ì‚° ê³µì‹
def calculate_output_size(H_in, F, P=0, S=1):
    # # ì£¼ì„: (ì…ë ¥ í¬ê¸° - í•„í„° í¬ê¸° + 2 * íŒ¨ë”©) / ìŠ¤íŠ¸ë¼ì´ë“œ + 1
    H_out = (H_in - F + 2 * P) // S + 1 
    return H_out

# 5-3. ê¸°í•˜ ì—°ì‚°: ë™ì°¨ ì¢Œí‘œë¥¼ ì´ìš©í•œ ì´ë™ (Translation Matrix)
def translation_matrix(tx, ty):
    # # ì£¼ì„: ì´ë™(tx, ty)ì„ í•˜ë‚˜ì˜ í–‰ë ¬ ê³±ì…ˆìœ¼ë¡œ í‘œí˜„. ë‹¤ë¥¸ ë³€í™˜ê³¼ ê²°í•© ê°€ëŠ¥
    M = [[1, 0, tx],
         [0, 1, ty],
         [0, 0, 1]]
    return M

# 5-4. ì–‘ì„ í˜• ë³´ê°„ (Bilinear Interpolation)
def bilinear_interpolation(p1, p2, p3, p4, a, b):
    # # ì£¼ì„: ì£¼ë³€ 4ê°œ í”½ì…€(p1~p4)ì„ ê°€ì¤‘ í‰ê· í•˜ì—¬ ìƒˆë¡œìš´ í”½ì…€ ê°’ ì¶”ì • (a, bëŠ” ê°€ì¤‘ì¹˜/ê±°ë¦¬)
    # p1(0,0), p2(1,0), p3(0,1), p4(1,1)
    value = (1-a)*(1-b)*p1 + a*(1-b)*p2 + (1-a)*b*p3 + a*b*p4
    return value

# 5-5. ì—ì§€ ê²€ì¶œ: ìºë‹ˆ ì—ì§€ (Canny Edge)ì˜ 4ë‹¨ê³„ (í”„ë¡œì„¸ìŠ¤ ìˆœì„œ)
CANNY_STEPS = [
    "1. Gaussian Blur (ì¡ìŒ ì œê±°)",
    "2. Gradient Calculation (ëª…ì•” ë³€í™”ìœ¨/ë°©í–¥ ê³„ì‚°)",
    "3. Non-Maximum Suppression (ê°€ì¥ ê°•í•œ ì—ì§€ë§Œ ì„ íƒ)",
    "4. Hysteresis Thresholding (ì´ë ¥ ì„ê³„ê°’ìœ¼ë¡œ ìµœì¢… ì—ì§€ ì—°ê²°)" # # ì£¼ì„: ì•½í•œ ì—ì§€ë¥¼ ì—°ê²°í•˜ì—¬ ì—ì§€ ì™„ì„±
]

# ==============================================================================
# 6ì£¼ì°¨ & 7ì£¼ì°¨: ì§€ì—­ íŠ¹ì§• ë° ë§¤ì¹­ (SIFT, Homography)
# ==============================================================================

# 6-1. SIFT íŠ¹ì§•ì  ê¸°ìˆ ì (Descriptor) ìƒì„± ì›ë¦¬
SIFT_DESCRIPTOR_CORE = "Keypoint Orientation Histograms" # # ì£¼ì„: íŠ¹ì§•ì  ì£¼ë³€ ì˜ì—­ì˜ ë°©í–¥ íˆìŠ¤í† ê·¸ë¨ì„ ì¶”ì¶œí•˜ì—¬ 128ì°¨ì› ë²¡í„°ë¡œ ë³€í™˜ (í¬ê¸°/íšŒì „ ë¶ˆë³€ì„± í™•ë³´)

# 6-2. ë§¤ì¹­ í•„í„°ë§: ìµœê·¼ì ‘ ê±°ë¦¬ ë¹„ìœ¨ (Nearest Neighbor Distance Ratio Test)
def distance_ratio_test(dist_nn1, dist_nn2, threshold=0.7):
    # # ì£¼ì„: ê°€ì¥ ê°€ê¹Œìš´ íŠ¹ì§•ì (NN1)ê³¼ ë‘ ë²ˆì§¸ ê°€ê¹Œìš´ íŠ¹ì§•ì (NN2)ì˜ ê±°ë¦¬ ë¹„ìœ¨ì„ ë¹„êµí•˜ì—¬ ì˜¤ë§¤ì¹­ ì œê±°
    if dist_nn1 / dist_nn2 < threshold:
        return True # ë§¤ì¹­ìœ¼ë¡œ ì¸ì • (ìœ íš¨í•œ ë§¤ì¹­)
    return False # # ì£¼ì„: ë¹„ìœ¨ì´ í¬ë©´ ëª¨í˜¸í•œ íŠ¹ì§•ì´ë¯€ë¡œ ì˜¤ë§¤ì¹­ìœ¼ë¡œ ê°„ì£¼

# 6-3. í˜¸ëª¨ê·¸ë˜í”¼ (Homography) í–‰ë ¬ ê³µì‹
HOMOGRAPHY_MATRIX = """
p' â‰ˆ H * p  (3x3 í–‰ë ¬)
# # ì£¼ì„: ì›ë³¸ í‰ë©´ ì¢Œí‘œ p (ë™ì°¨ì¢Œí‘œ (x, y, 1)T)ë¥¼ í˜¸ëª¨ê·¸ë˜í”¼ í–‰ë ¬ Hë¥¼ ê³±í•˜ì—¬ ë³€í™˜ëœ í‰ë©´ ì¢Œí‘œ p'ë¡œ ì‚¬ìƒí•¨
H = [[h11, h12, h13],
     [h21, h22, h23],
     [h31, h32, h33]]
"""

# 6-4. í˜¸ëª¨ê·¸ë˜í”¼ ì¶”ì • ì•Œê³ ë¦¬ì¦˜ (RANSAC ê¸°ë°˜)
def estimate_homography(good_matches):
    # # ì£¼ì„: RANSAC (Random Sample Consensus) ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë§¤ì¹­ ìŒì—ì„œ ì´ìƒì¹˜(Outlier)ë¥¼ ì œê±°
    # # ì£¼ì„: ìµœì¢…ì ìœ¼ë¡œ ê°€ì¥ ë§ì€ ë‚´ë¶€ì (Inlier)ì„ í¬í•¨í•˜ëŠ” ìµœì ì˜ í˜¸ëª¨ê·¸ë˜í”¼ í–‰ë ¬ Hë¥¼ ì¶”ì •
    H_matrix, mask = cv.findHomography(good_matches, method='RANSAC')
    return H_matrix
